# -*- coding: utf-8 -*-
"""h3task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_08or5WGnpRCDrxXSKeYUgQ-k1VXDWG_


!apt-get install openjdk-8-jdk

!wget -q https://archive.apache.org/dist/spark/spark-2.4.4/spark-2.4.4-bin-hadoop2.7.tgz

!tar xf spark-2.4.4-bin-hadoop2.7.tgz

!pip install -q findspark

import os
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"
os.environ["SPARK_HOME"] = "/content/spark-2.4.4-bin-hadoop2.7"

import findspark
findspark.init()

findspark.find()

"""



from pyspark import SparkContext
import random
import sys
import time
from itertools import combinations

sc = SparkContext.getOrCreate()

#input_data = "/content/drive/MyDrive/Colab Notebooks/DS 553/hw3/Copy of yelp_train.csv"

input_file = sys.argv[1]
output_file = sys.argv[2]

data = sc.textFile(input_file)

data.count()

data.take(5)

first_line = data.first()

rdd = data.filter(lambda x: x!=first_line).map(lambda x: x.split(','))

rdd.take(5)

rdd.count()

threshold = 0.5

u2 = rdd.map(lambda x: x[0]).distinct().collect()
len(u2)

userd ={}
for i,j in zip(u2, range(len(u2))):
    userd[i] = j

len(userd)

b1 = rdd.map(lambda x: (x[1])).distinct().collect()
len(b1)

bussd ={}
for i,j in zip(b1, range(len(b1))):
    bussd[i] = j

len(bussd)

business_user_list = rdd.map(lambda f : (f[1], f[0])).groupByKey().mapValues(set)

def get_list(matrix_input):
    return list(matrix_input)


def check_num(number):
    for i in range(2, int(number/2)+1):
        if (number % i) == 0:
            return False
        else:
            return True

global m
m = len(u2)

def hash_f(n):
    ax = {}
    bx = {}
    px = {}

    a = random.randint(1,99999)
    b = random.randint(1,99999)
    numbers = [i for i in range(1,99999) if check_num(i)]
    p = random.choice(numbers)

    ax[0] = a
    bx[0] = b
    px[0] = p

    for i in range(1, n):
        a = random.randint(1,99999)
        b = random.randint(1,99999)
        numbers = [i for i in range(1,99999) if check_num(i)]
        p = random.choice(numbers)

        ax[i] = a
        bx[i] = b
        px[i] = p

    return ax, bx, px


"""###### choosing 50 hash functions"""

par_a , par_b, par_p= hash_f(50)
#print("time: {} sec".format(t))

n = 50

def separate_chunks(x):
    X = get_list(x)

    bid, uids = X[0], X[1]

    return bid, uids



def signature(x, userD, n, par_a, par_b, par_p):
    
    bl, usl = separate_chunks(x)

    matrix = [float('inf') for i in range(n)]

    for u in usl:
        pos = userD[u]

        for i in range(n):
            hashed = ((par_a[i]*pos + par_b[i])% par_p[i]) % m
            if (hashed < matrix[i]):
                matrix[i] = hashed

    return matrix

signm = business_user_list.map(lambda x: (x[0], signature(x,userd,n,par_a,par_b,par_p)))

signm.count()

import time

bands = 25
rows = n // bands

rows



def separate_matrix(matrix_input):

    input_matrix = get_list(matrix_input)

    bid, hashed = input_matrix[0], input_matrix[1]

    return bid, hashed

def locality_sensitive_hashing(sigm_input,r):
    
    buckets = []

    bid, hashed = separate_matrix(sigm_input)

    b = 0
    
    for i in range(0, len(hashed), r):
        band = tuple(hashed[i : i + r])
        buckets.append(((b, band), bid))
        b += 1
        
    return buckets

def similarity(pair, business_matrix):

    b1 = business_matrix[pair[0]]
    b2 = business_matrix[pair[1]]

    common = len(b1.intersection(b2))
    all = len(b1.union(b2))

    ratio = float(common)/float(all)

    candidate = tuple(sorted(pair))
        
    return candidate, ratio


def create_combinations(input_item):

	pairs = get_list(input_item)
 
	return combinations(pairs, 2)



def do_LSH(signm):

    return signm.flatMap(lambda x: locality_sensitive_hashing(x,rows)).groupByKey().mapValues(list)

def get_similar_items(candidate):

    c = candidate.flatMap(lambda x: create_combinations(x)).distinct().persist()

    return c

candidate = do_LSH(signm)
candidate = candidate.map(lambda f: list(f[1])).filter(lambda f : len(f) > 1)


updated_candidate = get_similar_items(candidate)



def convert_dict(business_user_list):
    return {i: j for i, j in business_user_list.collect()}

bul = convert_dict(business_user_list)

def filtered_result(output_result):

    return output_result.filter(lambda f : f[1] >= 0.5).collect()

output_result = updated_candidate.map(lambda x: similarity(x,bul))

filtered_pairs = filtered_result(output_result)

filtered_pairs.sort()



result = "business_id_1, business_id_2, similarity\n"

for item in sorted(filtered_pairs):
    result += str(item[0][0])+','+str(item[0][1])+','+str(item[1])+"\n"

#print(result, 'utf-8')

with open(output_file, 'w') as f:
    f.write(result)












